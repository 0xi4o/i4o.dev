---
title: The NPM package stack that you should try in 2023
slug: npm-package-stack-2023
date_published: 2023-03-10T00:00:00.000Z
date_updated: 2023-03-10T08:06:28.000Z
draft: true
---

I started off this year building two projects that are meant to be deployed as NPM packages — [Catalyst UI](https://catalyst-ui.com/) and [Rescribe](https://rescribe.site/).

I built and deployed an NPM package years ago at work. At that time, not knowing better, I didn't automate anything. Every time I made a change to the package, I manually ran the build script, tested it on an example repo by manually updating the package, logged into npm from the terminal, and ran npm publish.

This time around, I wanted to do it differently — modern tooling, automation, etc. This is the stack I ended up with, by checking what popular libraries are using and what interested me.

## Monorepo with TurboRepo

If you're building any sort of shared libraries or npm packages, using a monorepo is the easiest way to do it. I used to be scared of monorepos. I tried to learn Lerna a few times but it seemed so daunting.

Turborepo changed that and made it easy to manage monorepos. It's a build system for JS/TS codebases that takes care of running tasks like linting, testing, and building. And it does that super fast by leveraging caching, both locally and remotely. Running a build task but nothing changed from the last build? Turborepo won't do the build again. It would just return the cached version.

You can configure Turborepo using a turbo.json file located in the project root. I rarely touch this file though. If you're using the create-turbo command, it generates a starter that has a turbo.json pre-configured and ready to go.

In a monorepo setup you will have your website or app, shared libraries, and even shared configurations all in one repo.

For example, I put all my shared libs and configurations in a packages folder in the project root. I then create a different directory for the website(s) or app(s). Now you just have to declare your workspaces in your root package.json file.

    {
        "workspaces": [
            "apps/*",
            "packages/*"
        ]
    }

Now that we have the build system sorted out, let's manage our dependencies. Here's where pnpm workspaces come in.

## Pnpm Workspaces

I recently moved from yarn to pnpm for Node package management. I made the switch because of the mess that is yarn versions (I still stayed on 1.22) but it worked out quite well because I found pnpm workspaces to be quite easy to use.

I just have to create a `pnpm-workspace.yaml` file and define my packages.

    packages:
      - "apps/*"
      - "packages/*"

In a monorepo, there'll be multiple projects under one roof. Each of those will have its own dependencies and most probably, will depend on one another. Pnpm makes it easy to target specific workspaces from the project root.

We do that using the `--filter` flag. For example, let's say we want to install a dependency to a workspace called ui under packages. You just have to do this:

    pnpm add react react-dom --filter ui

This will install react and react-dom to only the workspace you defined. No need to traverse directories everytime.

## Tsup

If you're writing a library, you have to use TypeScript. Even if the users of the library don't use TypeScript, writing the library in TypeScript has some benefits.

1.  Editors can detect types in your library and do autocompletions
    
2.  It helps you write a better library by giving you clarity on the data you're handling
    
3.  If your users are using TypeScript, they can use the types you expose in their codebase.
    

Coming back to [tsup](https://github.com/egoist/tsup). It is a bundler that's made for building TypeScript libraries and is built on top of [esbuild](https://github.com/evanw/esbuild). It's fast and needs no configuration to get started.

## Changesets

[Changesets](https://github.com/changesets/changesets) is one of those things that make life as a library author so much easier. Many popular libraries use changesets to automate versioning and publishing. It even generates changelogs for each version!

Everytime there's a change in one of the packages, run:

    pnpm changeset

Changeset will detect which package has changed, or give us the choice to select all packages. Then it will prompt us to select the type of change, following the semver rules — major, minor, and patch. Based on the selection, changeset will update the version and create a pull request.

Once the pull request is merged, changeset will publish the package to NPM repository.

To handle all of this, we have to write some configuration ahead of time, including Github Actions for publishing to NPM. Changeset even has a pre-built action that we can use in our Github Action.

For example, here's a simple Github Action that I use for publishing Catalyst:

    name: Publish
    on:
        push:
            branches:
                - 'main'
    
    concurrency: ${{ github.workflow }}-${{ github.ref }}
    
    jobs:
        build:
            name: Release
            runs-on: ubuntu-latest
            steps:
                - uses: actions/checkout@v3
                - uses: pnpm/action-setup@v2
                  with:
                      version: 7
                - uses: actions/setup-node@v3
                  with:
                      node-version: 16.x
                      cache: 'pnpm'
    
                - run: pnpm install --frozen-lockfile
                - name: Create Release Pull Request or Publish
                  id: changesets
                  uses: changesets/action@v1
                  with:
                      publish: pnpm run release
                  env:
                      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

## Github Actions

Of course, automating the publishing part of the package won't be possible without some sort of CI/CD, like Github Actions.

With a simple YAML file like the one above, Github Actions will run the tasks required for building and publishing the package whenever there are code changes to the `main` branch.

One of the tasks is a `release` script in the root `package.json` file:

    "release": "turbo run build --filter @i4o/catalystui && changeset publish"

This will make changeset do it's thing — generating a new version, pushing to NPM, creating a changelog, and publishing a new release in the Github repository.

* * *

So there you have it. This is the stack that makes it easy to publish a library to NPM. I've used this stack to publish 2 packages this year. I hope this was useful to you.

Thanks for reading!
